-- Pour la création de la base sur le teleporter
/*
sudo -i -u postgres psql

postgres#= CREATE USER "okanban" WITH ENCRYPTED PASSWORD 'okanban';
postgres#= CREATE DATABASE "okanban" WITH OWNER "okanban"; -- CREATE DATABASE <dbname> WITH OWNER <username>
postgres#= \q
*/

-- Modèle physique de données (MPD)

BEGIN; -- Débute une transaction = si l'une des commandes échoue, elles échouent toutes !

-- Pour pouvoir relancer le script, on supprime les tables d'abord
-- On peut supprimer toutes les tables dans la même instruction, cela simplifie la tâche par rapport aux potentiels soucis de contrintes de clé étrangères
DROP TABLE IF EXISTS "list", "card", "tag", "card_has_tag";

CREATE TABLE "list" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "title" TEXT NOT NULL,
  "position" INTEGER NOT NULL DEFAULT 1,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,-- ou now()
  "updated_at" TIMESTAMPTZ
);

CREATE TABLE "card" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "content" TEXT NOT NULL,
  "position" INTEGER NOT NULL DEFAULT 1,
  "color" CHAR(7),-- forcement 7 caractères #123456
  "list_id" INTEGER NOT NULL REFERENCES "list"("id") ON DELETE CASCADE, -- On ajoute un effet evenementiel : si on supprime une liste, on supprime les cartes associées par effet de cascade
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ
);

-- REFERENCES "list"("id") ===> si une carte pointe vers une list qui n'existe pas, ça plante !
-- ON DELETE CASCADE       ===> si on supprime la liste, les cartes de la liste sont supprimées automatiquement
--                         ===> autre solution, ne PAS mettre ce ON DELETE CASCADE et à ce moment là, il faudra obligatoirement vider les cartes avant de supprimer les listes !                          

CREATE TABLE "tag" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" TEXT NOT NULL UNIQUE,
  "color" CHAR(7),
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ
);


CREATE TABLE "card_has_tag" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  "card_id" INTEGER NOT NULL REFERENCES "card"("id") ON DELETE CASCADE,
  "tag_id" INTEGER NOT NULL REFERENCES "tag"("id") ON DELETE CASCADE,

  UNIQUE ("card_id", "tag_id"), -- Le couple card_id + tag_id doit etre unique

  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ
);

-- On aurait pu ne pas mettre d'ID à cette table card_has_tag et à la place, mettre une clé primaire COMPOSITE : 
-- = une clé primaire composée de 2 champs

-- UNIQUE ("card_id", "tag_id"), ==> on peut pas avoir deux fois le même tag sur la même carte

-- Alternativement, on peut expliciter la contrainte de clé étrangère au niveau de la table :
-- "card_id" INTEGER NOT NULL ON DELETE CASCADE,
-- FOREIGN KEY ("card_id") REFERENCES "card"("id"),


COMMIT; -- Fin de la transaction
-- En cas d'erreur, la BDD fera un ROLLBACK pour annuler les modifications
